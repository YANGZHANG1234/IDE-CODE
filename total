#include <Adafruit_NeoPixel.h>
#include "HX711.h"
#include <Servo.h>
#include <Wire.h>
#include <RTClib.h>
#include <Adafruit_GC9A01A.h>
#include "SPI.h"
#include "Adafruit_GFX.h"

//led引脚定义
#define Led1 22 //led1
#define Led2 24 //led2
#define Led3 26  //led3
#define NUMPIXELS 8

Adafruit_NeoPixel strip1 = Adafruit_NeoPixel(NUMPIXELS, Led1, NEO_GRBW + NEO_KHZ800);
Adafruit_NeoPixel strip2 = Adafruit_NeoPixel(NUMPIXELS, Led2, NEO_GRBW + NEO_KHZ800);
Adafruit_NeoPixel strip3 = Adafruit_NeoPixel(NUMPIXELS, Led3, NEO_GRBW + NEO_KHZ800);

// servo 引脚定义
Servo myServo1;  
Servo myServo2;          // 第一个伺服电机
#define servoPin1 9 
#define servoPin2 10  // Pin where the servo is connected
const int initialPosition = 0;  // Initial position of the servo
  // Initial position of the servo

//红外线
#define irSensorPin1 2     // Pin where the IR sensor is connected
#define irSensorPin2 3

//pill consideration
const int desired_pill = 3;     // 传参部分
volatile int pill_count1 = 0;   // 第一个红外传感器的药丸计数器
volatile int pill_count2 = 0;   // 第二个红外传感器的药丸计数器

//称重传感器
#define DT1_PIN 53 //weight 1
#define SCK1_PIN 52
#define DT2_PIN 51 //weight 2
#define SCK2_PIN 50
HX711 scale1;
HX711 scale2;
float scale1_factor = 0;  // scale1 的因子到时候去定义
float scale2_factor = 0;  // scale2 的因子

//motor
#define motorPin1 11     // 连接到H桥驱动器的AIN1
#define motorPin2 12    // 连接到H桥驱动器的AIN2

//button Pin
#define buttonPin 13    // 连接到按钮的引脚
bool motorRunning = false;   // 电机运行状态标志

//Potential meter
#define potmeterPin1 A0
#define potmeterPin2 A1
#define potmeterPin3 A2
int potmeterVal1 = 0;
int potmeterVal2 = 0;
int potmeterVal3 = 0;

//Screen pin
#define TFT_DC 7
#define TFT_CS 6

//Encoder pins
#define ENC_A 18
#define ENC_B 19
Adafruit_GC9A01A tft(TFT_CS, TFT_DC);
unsigned long _lastIncReadTime = micros();
unsigned long _lastDecReadTime = micros();
int _pauseLength = 25000;
int set_time = 10;//时钟读数
int now_time = 8;//往时钟读数
volatile int counter = 0;
int lastEndAngle = 0; // Store the end angle for drawing the arc
bool screenIsActive = false; // Track if the screen is currently active
int lastKnownCounter = 0; // Store the last counter value to redraw the previous arc

//出粮按钮
#define Feed_pin 28

RTC_DS1307 rtc;

void setLEDs(Adafruit_NeoPixel& strip, int value) {
    if (value == 0) {
        strip.clear();
    } else {
        for (int i = 0; i < NUMPIXELS; i++) {
            if (i < value) {
                strip.setPixelColor(i, strip.Color(0, 0, 0, 255)); // 设置为白色
            } else {
                strip.setPixelColor(i, strip.Color(0, 0, 0, 0)); // 熄灭
            }
        }
    }
    strip.show();
}

void checkAndSetLEDs() {
    int potValue1 = analogRead(POT1);
    int potValue2 = analogRead(POT2);
    int potValue3 = analogRead(POT3);

    int mappedValue1 = mapPotmeterValue(potValue1);
    int mappedValue2 = mapPotmeterValue(potValue2);
    int mappedValue3 = mapPotmeterValue(potValue3);

    // 更新LED前检查每个滑动变阻器的值是否有变化
    if (mappedValue1 != lastPotValue1) {
        lastChangeTime = millis();
        lastPotValue1 = mappedValue1;
        setLEDs(strip1, mappedValue1);
    }
    if (mappedValue2 != lastPotValue2) {
        lastChangeTime = millis();
        lastPotValue2 = mappedValue2;
        setLEDs(strip2, mappedValue2);
    }
    if (mappedValue3 != lastPotValue3) {
        lastChangeTime = millis();
        lastPotValue3 = mappedValue3;
        setLEDs(strip3, mappedValue3);
    }

    // 如果30秒无变化，则关闭LED
    if (millis() - lastChangeTime > 3000) {
        strip1.clear();
        strip2.clear();
        strip3.clear();
        strip1.show();
        strip2.show();
        strip3.show();
    }
}

void turning_servo1() {
  // Move servo from initial position to 180 degrees in steps of 10 degrees
  for (int angle = initialPosition; angle <= 180; angle += 10) {
    myServo1.write(angle);
    delay(200);
  }
  
  // Move servo back from 180 degrees to initial position in steps of 10 degrees
  for (int angle = 180; angle >= initialPosition; angle -= 10) {
    myServo1.write(angle);
    delay(200);
  }
}

void turning_servo2() {
  // Move servo from initial position to 180 degrees in steps of 10 degrees
  for (int angle = initialPosition; angle <= 180; angle += 10) {
    myServo2.write(angle);
    delay(200);
  }
  
  // Move servo back from 180 degrees to initial position in steps of 10 degrees
  for (int angle = 180; angle >= initialPosition; angle -= 10) {
    myServo2.write(angle);
    delay(200);
  }
}

void detectPill1() {
  pill_count1++;
  if (pill_count1 >= desired_pill) {
    // 第一个传感器达到需要的药丸数量
  }
}

void detectPill2() {
  pill_count2++;
  if (pill_count2 >= desired_pill) {
    // 第二个传感器达到需要的药丸数量
  }
}

void clearSerialBuffer() {
  while (Serial.available()) {
    Serial.read();
  }
}

uint32_t readWeightFromSerial() {
  while (!Serial.available());  // Wait for user input
  return Serial.parseInt();
}

void calibrate() {
  Serial.println("\n\nCALIBRATION\n===========");
  Serial.println("Remove all weight from the loadcell.");
  clearSerialBuffer();

  Serial.println("Press ENTER to zero the scale.");
  while (!Serial.available());  // Wait for user to press enter
  clearSerialBuffer();  // Ensure any extra input is cleared after pressing enter

  Serial.println("Determining zero weight offset...");
  scale1.tare(20);  // Average 20 measurements to zero the scale
  scale2.tare(20);  // Average 20 measurements to zero the scale

  float offset1 = scale1.get_offset();
  float offset2 = scale2.get_offset();

  Serial.print("OFFSET1: ");
  Serial.println(offset1);
  Serial.print("OFFSET2: ");
  Serial.println(offset2);
  Serial.println();

  Serial.println("Place a known weight on the loadcell.");
  Serial.println("After placing the weight, press ENTER.");
  while (!Serial.available());  // Wait for user to press enter after placing the weight
  clearSerialBuffer();  // Clear any additional inputs after pressing enter

  Serial.println("Enter the weight in grams and press ENTER.");
  uint32_t weight = readWeightFromSerial();  // Use a robust function to read weight

  Serial.print("WEIGHT: ");
  Serial.println(weight);

  scale1.calibrate_scale(weight, 20);  // Use the user-provided weight to calibrate the scale
  scale2.calibrate_scale(weight, 20);  // Use the user-provided weight to calibrate the scale

  scale1_factor = scale1.get_scale();
  scale2_factor = scale2.get_scale();

  Serial.print("SCALE1: ");
  Serial.println(scale1_factor, 6);
  Serial.print("SCALE2: ");
  Serial.println(scale2_factor, 6);
  Serial.println("Calibration complete. Ready to measure.");
}

void read_weight() {
  if (scale1.is_ready() && scale2.is_ready()) {
    // 读取当前重量
    float weight1 = scale1.get_units(5);  // Reduce the number of samples to speed up
    float weight2 = scale2.get_units(5);  // Reduce the number of samples to speed up

    // 计算两个传感器的平均重量
    float combined_weight = (weight1 + weight2) / 2;

    // 打印当前重量和两个传感器的平均重量
    Serial.print("传感器1: ");
    Serial.print(weight1, 2);
    Serial.print(" g");

    Serial.print(" | 传感器2: ");
    Serial.print(weight2, 2);
    Serial.print(" g");

    Serial.print(" | 平均重量: ");
    Serial.print(combined_weight, 2);
    Serial.println(" g");
  } else {
    Serial.println("等待HX711准备好...");
  }
}

//暂时先使用motor setting
void motor_setting(){

  analogWrite(motorPin1, 255); // 设置PWM值，电机半速正转60
  analogWrite(motorPin2, 0);   // 反向引脚设置为低
  delay(5000);
  analogWrite(motorPin1, 0); // 设置PWM值，电机半速正转
  analogWrite(motorPin2, 255);   // 反向引脚设置为低60
  delay(5000);
}

String getCurrentTime() {
  DateTime now = rtc.now();
  char buffer[20];
  sprintf(buffer, "%04d/%02d/%02d %02d:%02d:%02d", 
          now.year(), now.month(), now.day(), 
          now.hour(), now.minute(), now.second());
  return String(buffer);
}

// 比较两个时间是否相等的函数
bool isTimeEqual(DateTime t1, DateTime t2) {
  return (t1.year() == t2.year() &&
          t1.month() == t2.month() &&
          t1.day() == t2.day() &&
          t1.hour() == t2.hour() &&
          t1.minute() == t2.minute() &&
          t1.second() == t2.second());
}

int mapPotmeterValue(int val) {
  if (val == 0)
    return 0;
  else if (val < 28)
    return 0;
  else if (val < 280)
    return 1;
  else if (val < 586)
    return 2;
  else if (val < 953)
    return 3;
  else
    return 4;
}

void read_encoder() {
    // Encoder interrupt routine for both pins. Updates counter
    // if they are valid and have rotated a full indent
    static uint8_t old_AB = 3;  // Lookup table index
    static int8_t encval = 0;   // Encoder value
    static const int8_t enc_states[] = {
        0, -1, 1, 0,
        1, 0, 0, -1,
        -1, 0, 0, 1,
        0, 1, -1, 0
    };  // Lookup table
    old_AB <<= 2;  // Remember previous state
    if (digitalRead(ENC_A)) old_AB |= 0x02;  // Add current state of pin A
    if (digitalRead(ENC_B)) old_AB |= 0x01;  // Add current state of pin B
    encval += enc_states[old_AB & 0x0f];
    // Update counter if encoder has rotated a full indent, that is at least 4 steps
    if (encval > 1) {  // Four steps forward
        int changevalue = 1;
        if ((micros() - _lastIncReadTime) < _pauseLength) {
            changevalue = 10 * changevalue;
        }
        _lastIncReadTime = micros();
        counter = counter + changevalue;
        encval = 0;
    } else if (encval < -1) {  // Four steps backward
        int changevalue = -1;
        if ((micros() - _lastDecReadTime) < _pauseLength) {
            changevalue = 10 * changevalue;
        }
        _lastDecReadTime = micros();
        counter = counter + changevalue;
        encval = 0;
    }
}

//FUNCTION DRAW THICK CIRCLE
void drawThickCircle(uint16_t x, uint16_t y, uint8_t radius, uint16_t color, uint8_t lineWidth) {
    // Start from one radius less than the main radius and increment up to add the line width
    for (int i = 0; i < lineWidth; i++) {
        tft.drawCircle(x, y, radius - lineWidth/2 + i, color);
        
    }
}

//FUNCTION DRAW ARC
void drawArc(int16_t x, int16_t y, uint16_t radius, uint16_t startAngle, uint16_t arcLength, uint16_t color, uint8_t thickness) {
    float startRad = (startAngle - 90) * DEG_TO_RAD; // Convert degrees to radians, adjusting for 12 o'clock start
    float arcRad = arcLength * DEG_TO_RAD;
    float endRad = startRad + arcRad;
    for (int i = 0; i < thickness; i++) {
        for (float angle = startRad; angle < endRad; angle += 0.02) { // Increment by small radians for smoother arc
            int16_t x0 = x + (radius - i) * cos(angle);
            int16_t y0 = y + (radius - i) * sin(angle);
            int16_t x1 = x + (radius - i) * cos(angle + 0.02);
            int16_t y1 = y + (radius - i) * sin(angle + 0.02);
            tft.drawLine(x0, y0, x1, y1, color); // Draw line segment
        }
    }
}

// FUNTION UPDATEARC
void updateArc(int newCounter, int oldCounter) {
    int startAngle = 0;  // Start drawing from 12 o'clock
    uint16_t color = newCounter > oldCounter ? GC9A01A_WHITE : GC9A01A_BLACK;
    int arcLength = abs(newCounter - oldCounter) * 4;  // Determine the length of the arc to draw or erase
    uint8_t thickness = newCounter > oldCounter ? 5 : 7;  // Thicker arc for erasing

    // Calculate the angle based on the smaller counter
    int angleOffset = min(newCounter, oldCounter) * 4;
    lastEndAngle = startAngle + angleOffset + arcLength;
    drawArc(120, 120, 110, startAngle + angleOffset, arcLength, color, thickness);
}

//FUNCTION DRAW PREVIOUS ARC
void drawPreviousArc() {
    int startAngle = 0;
    int arcLength = lastKnownCounter * 4; // Calculate previous arc length
    drawArc(120, 120, 110, startAngle, arcLength, GC9A01A_WHITE, 5); // Assuming the previous color and thickness
}

//FUNCTION DRAW POINT ON CIRCLE
void drawPointOnCircle(int16_t x0, int16_t y0, uint16_t radius, uint8_t hour, uint16_t color, uint8_t pointSize) {
    float angle = (hour % 12) * 30 - 90; // Convert hour to angle (clock starts from -90 degrees).
    float radian = angle * DEG_TO_RAD;
    int16_t x = x0 + radius * cos(radian);
    int16_t y = y0 + radius * sin(radian);
    tft.fillCircle(x, y, pointSize, color);
}

void displaySetDone() {
  tft.setCursor(52, 113);
  tft.setTextSize(3);
  tft.setTextColor(GC9A01A_WHITE);
  tft.println("Set Done");
  delay(3000);
  tft.fillScreen(GC9A01A_BLACK); // Change the screen to black
  drawThickCircle(120,120,110,GC9A01A_WHITE,5);
  drawPointOnCircle(120, 120, 100, now_time, GC9A01A_GREEN, 5);
  drawPointOnCircle(120, 120, 110, set_time, GC9A01A_WHITE, 5);
  tft.setCursor(105, 20);
  tft.setTextSize(3);
  tft.setTextColor(GC9A01A_WHITE);
  tft.println(12);
  tft.setCursor(112, 200);
  tft.setTextSize(3);
  tft.setTextColor(GC9A01A_WHITE);
  tft.println(6);
  tft.setCursor(22, 114);
  tft.setTextSize(3);
  tft.setTextColor(GC9A01A_WHITE);
  tft.println(9);
  tft.setCursor(207, 114);
  tft.setTextSize(3);
  tft.setTextColor(GC9A01A_WHITE);
  tft.println(3);
  delay(2000);
  tft.setCursor(80, 113);
  tft.setTextSize(2);
  tft.setTextColor(GC9A01A_WHITE);
  tft.println("Set Time");
  tft.fillCircle(120, 96, 5, GC9A01A_WHITE);
  delay(5000);
  tft.fillCircle(120, 120, 80, GC9A01A_BLACK);
  tft.setCursor(55, 113);
  tft.setTextSize(2);
  tft.setTextColor(GC9A01A_WHITE);
  tft.println("Current Time");
  tft.fillCircle(120, 96, 5, GC9A01A_GREEN);
  delay(5000);
  tft.fillCircle(120, 120, 80, GC9A01A_BLACK);
}

unsigned long testText(int Output_Result) {
  tft.fillCircle(120, 120, 100, GC9A01A_BLACK);
  unsigned long start = micros();
  if (Output_Result < 100 && Output_Result >0) {
        tft.setCursor(65, 86);
        tft.setTextSize(10);
    } else if (Output_Result >= 1000) {
        tft.setCursor(20, 95);
        tft.setTextSize(8);
    } else if (Output_Result == 0) {
        tft.setCursor(98, 86);
        tft.setTextSize(10);
    } else {
        tft.setCursor(37, 86);
        tft.setTextSize(10);
    }
  tft.setTextColor(GC9A01A_WHITE);  
  tft.println(Output_Result);
  if (Output_Result<=200){
    tft.setCursor(70, 170);
    tft.setTextSize(2);
    tft.setTextColor(GC9A01A_WHITE);  
    tft.println("Small Dog");
  } else if (Output_Result<=500){
    tft.setCursor(60, 170);
    tft.setTextSize(2);
    tft.setTextColor(GC9A01A_WHITE);  
    tft.println("Medium Dog");
  } else if (Output_Result<=900){
    tft.setCursor(73, 170);
    tft.setTextSize(2);
    tft.setTextColor(GC9A01A_WHITE);  
    tft.println("Large Dog");
  } else if (Output_Result>900){
    tft.setCursor(73, 170);
    tft.setTextSize(2);
    tft.setTextColor(GC9A01A_WHITE);  
    tft.println("Giant Dog");
  }
  return micros() - start;
}
static unsigned long lastUpdateTime = millis(); // Time when the counter was last updated

void setup() {
  //led1
  strip1.begin();
  strip1.show();
  setColors(strip1);
  //led2
  strip2.begin();
  strip2.show();
  setColors(strip2);
  //led3
  strip3.begin();
  strip3.show();
  setColors(strip3);
  //servo
  myServo1.attach(servoPin1);
  myServo1.attach(servoPin2);
  //isr
  pinMode(irSensorPin1, INPUT);
  pinMode(irSensorPin2, INPUT);
  attachInterrupt(digitalPinToInterrupt(irSensorPin1), detectPill1, FALLING); // 设置第一个红外传感器的中断
  attachInterrupt(digitalPinToInterrupt(irSensorPin2), detectPill2, FALLING); // 设置第二个红外传感器的中断
  myServo1.write(initialPosition);
  myServo2.write(initialPosition);
  //weight初始化HX711
  scale1.begin(DT1_PIN, SCK1_PIN);
  scale2.begin(DT2_PIN, SCK2_PIN);
  //motor 
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(buttonPin, INPUT_PULLUP);
  
  // 设置按钮引脚为输入，并启用内部上拉电阻

  // 校准传感器
  calibrate();

  // rtc时钟
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
    while (1);
  }
  // 获取当前编译时间
  DateTime compileTime(F(__DATE__), F(__TIME__));
  // 获取RTC当前时间
  DateTime rtcTime = rtc.now();

  // 检查RTC时间是否失效或与编译时间不一致
  if (!rtc.isrunning() || !isTimeEqual(rtcTime, compileTime)) {
    Serial.println("RTC lost power or time mismatch, setting the time!");
    rtc.adjust(compileTime);
  }
  tft.begin();

#if defined(TFT_BL)
  pinMode(TFT_BL, OUTPUT);
  digitalWrite(TFT_BL, HIGH); // Backlight on
#endif // end TFT_BL

  //tft.drawCircle(120, 120, 110,GC9A01A_WHITE);
  tft.fillScreen(GC9A01A_BLACK);


  pinMode(ENC_A, INPUT_PULLUP);
  pinMode(ENC_B, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_A), read_encoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENC_B), read_encoder, CHANGE);
}

void loop(){
  int switchState = digitalRead(switchPin); 
  if (switchState == HIGH) {
    digitalWrite(ledPin, HIGH); // 如果滑块开关处于高电平，点亮LED
  } else {
   
  }
}
